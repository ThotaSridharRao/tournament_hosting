<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tournament Brackets | GamingNexus</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap"
        rel="stylesheet" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="navbar.css">
    <!-- jsPDF for PDF generation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.23/jspdf.plugin.autotable.min.js"></script>

    <style>
        :root {
            --primary-color: #0f85d3;
            --bg-dark: #0D0A1A;
            --accent-secondary: #5D3FD3;
            --panel: #161329;
            --text-primary: #F0F0F0;
            --text-secondary: rgba(240, 240, 240, 0.7);
            --border-color: rgba(10, 250, 217, 0.2);
            --ease: 0.3s ease;
            --radius: 12px;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: var(--bg-dark);
            color: var(--text-primary);
            margin: 0;
            padding: 0;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
        }

        .header {
            text-align: center;
            margin-bottom: 2rem;
        }

        .tournament-title {
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
            background: linear-gradient(135deg, var(--primary-color), var(--accent-secondary));
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .tournament-info {
            display: flex;
            justify-content: center;
            gap: 2rem;
            margin-bottom: 2rem;
            flex-wrap: wrap;
        }

        .info-item {
            background: var(--panel);
            padding: 1rem 1.5rem;
            border-radius: var(--radius);
            border: 1px solid var(--border-color);
        }

        .brackets-container {
            background: var(--panel);
            border-radius: var(--radius);
            border: 1px solid var(--border-color);
            padding: 2rem;
            overflow-x: auto;
        }

        .bracket-round {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            min-width: 250px;
            margin-right: 2rem;
        }

        .bracket-match {
            background: rgba(15, 133, 211, 0.1);
            border: 1px solid var(--primary-color);
            border-radius: var(--radius);
            padding: 1rem;
            position: relative;
        }

        .match-teams {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .team {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
            transition: var(--ease);
        }

        .team.winner {
            background: rgba(40, 167, 69, 0.2);
            border: 1px solid #28a745;
        }

        .team.loser {
            opacity: 0.6;
        }

        .team-name {
            font-weight: 600;
        }

        .team-score {
            font-weight: 700;
            color: var(--primary-color);
        }

        .match-status {
            text-align: center;
            margin-top: 0.5rem;
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        .rounds-container {
            display: flex;
            align-items: flex-start;
            gap: 2rem;
            padding: 1rem 0;
        }

        .round-title {
            text-align: center;
            font-weight: 600;
            margin-bottom: 1rem;
            color: var(--primary-color);
        }

        .no-brackets {
            text-align: center;
            padding: 3rem;
            color: var(--text-secondary);
        }

        .loading {
            text-align: center;
            padding: 3rem;
        }

        .back-button {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            background: var(--primary-color);
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: var(--radius);
            text-decoration: none;
            font-weight: 600;
            transition: var(--ease);
            margin-bottom: 2rem;
        }

        .back-button:hover {
            background: var(--accent-secondary);
            transform: translateY(-2px);
        }

        .format-info {
            background: rgba(93, 63, 211, 0.1);
            border: 1px solid var(--accent-secondary);
            border-radius: var(--radius);
            padding: 1rem;
            margin-bottom: 2rem;
        }

        .participants-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .participant-card {
            background: var(--panel);
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            padding: 1rem;
        }

        .participant-card h4 {
            margin: 0 0 0.5rem 0;
            color: var(--primary-color);
        }

        .seed-number {
            background: var(--accent-secondary);
            color: white;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.8rem;
            font-weight: 600;
        }

        .matches-section {
            margin-top: 3rem;
        }

        .match-table {
            width: 100%;
            background: var(--panel);
            border-radius: var(--radius);
            border: 1px solid var(--border-color);
            margin-bottom: 2rem;
            overflow: hidden;
        }

        .match-table th,
        .match-table td {
            padding: 1rem;
            text-align: left;
            border-bottom: 1px solid var(--border-color);
        }

        .match-table th {
            background: rgba(15, 133, 211, 0.1);
            font-weight: 600;
            color: var(--primary-color);
        }

        .match-table tr:last-child td {
            border-bottom: none;
        }

        .match-table tr:hover {
            background: rgba(255, 255, 255, 0.02);
        }

        .match-number {
            font-weight: 700;
            color: var(--accent-secondary);
        }

        .vs-separator {
            color: var(--text-secondary);
            font-weight: 600;
            margin: 0 0.5rem;
        }

        .download-section {
            background: var(--panel);
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            padding: 2rem;
            text-align: center;
            margin-top: 3rem;
        }

        .download-btn {
            background: linear-gradient(135deg, var(--primary-color), var(--accent-secondary));
            color: white;
            padding: 1rem 2rem;
            border: none;
            border-radius: var(--radius);
            font-weight: 600;
            font-size: 1.1rem;
            cursor: pointer;
            transition: var(--ease);
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
        }

        .download-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(15, 133, 211, 0.3);
        }

        .download-btn:disabled {
            background: #6c757d;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .download-btn.admin-only {
            background: linear-gradient(135deg, #6c757d, #495057);
            border: 1px solid #6c757d;
        }

        .download-btn.admin-only:hover {
            transform: none;
            box-shadow: none;
        }

        .status-badge {
            padding: 0.25rem 0.75rem;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 600;
            text-transform: uppercase;
        }

        .status-registration-open {
            background: rgba(40, 167, 69, 0.2);
            color: #28a745;
            border: 1px solid #28a745;
        }

        .status-registration-closed {
            background: rgba(255, 193, 7, 0.2);
            color: #ffc107;
            border: 1px solid #ffc107;
        }

        .status-active {
            background: rgba(15, 133, 211, 0.2);
            color: var(--primary-color);
            border: 1px solid var(--primary-color);
        }

        .status-completed {
            background: rgba(108, 117, 125, 0.2);
            color: #6c757d;
            border: 1px solid #6c757d;
        }

        .round-section {
            margin-bottom: 3rem;
        }

        .round-header {
            background: linear-gradient(135deg, var(--primary-color), var(--accent-secondary));
            color: white;
            padding: 1rem 1.5rem;
            border-radius: var(--radius) var(--radius) 0 0;
            font-weight: 700;
            font-size: 1.2rem;
        }

        .tournament-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .stat-card {
            background: var(--panel);
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            padding: 1.5rem;
            text-align: center;
        }

        .stat-number {
            font-size: 2rem;
            font-weight: 700;
            color: var(--primary-color);
            display: block;
        }

        .stat-label {
            color: var(--text-secondary);
            font-size: 0.9rem;
            margin-top: 0.5rem;
        }

        /* Tournament Brackets Styling */
        .stage-section {
            margin-bottom: 3rem;
        }

        .stage-header {
            background: linear-gradient(135deg, var(--primary-color), var(--accent-secondary));
            color: white;
            padding: 1.5rem;
            border-radius: var(--radius) var(--radius) 0 0;
            margin-bottom: 0;
        }

        .stage-header h4 {
            margin: 0 0 0.5rem 0;
            font-size: 1.3rem;
        }

        .stage-header p {
            margin: 0;
            opacity: 0.9;
        }

        .match-table-container {
            background: var(--panel);
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            margin-bottom: 2rem;
            overflow: hidden;
        }

        .match-table-header {
            background: rgba(15, 133, 211, 0.1);
            padding: 1rem 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border-color);
        }

        .match-table-header h5 {
            margin: 0;
            color: var(--primary-color);
            font-size: 1.1rem;
        }

        .match-count {
            background: var(--primary-color);
            color: white;
            padding: 0.25rem 0.75rem;
            border-radius: 15px;
            font-size: 0.85rem;
            font-weight: 600;
        }

        .match-table {
            width: 100%;
            border-collapse: collapse;
        }

        .match-table th,
        .match-table td {
            padding: 1rem;
            text-align: left;
            border-bottom: 1px solid var(--border-color);
        }

        .match-table th {
            background: rgba(0, 0, 0, 0.1);
            font-weight: 600;
            color: var(--text-primary);
        }

        .match-table tr:hover {
            background: rgba(15, 133, 211, 0.05);
        }

        .match-table tr:last-child td {
            border-bottom: none;
        }

        .match-number {
            font-weight: 700;
            color: var(--accent-secondary);
            text-align: center;
        }

        .match-teams {
            font-weight: 500;
        }

        .match-status {
            padding: 0.25rem 0.75rem;
            border-radius: 15px;
            font-size: 0.85rem;
            font-weight: 600;
            text-align: center;
            background: rgba(108, 117, 125, 0.2);
            color: #6c757d;
        }

        .match-schedule {
            color: var(--text-secondary);
        }

        .finalists-section {
            margin-top: 3rem;
        }

        .finalists-table-container {
            background: var(--panel);
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            overflow: hidden;
        }

        .finalists-table {
            width: 100%;
            border-collapse: collapse;
        }

        .finalists-table th,
        .finalists-table td {
            padding: 1rem;
            text-align: center;
            border-bottom: 1px solid var(--border-color);
        }

        .finalists-table th {
            background: linear-gradient(135deg, #FFD700, #FFA500);
            color: #000;
            font-weight: 700;
        }

        .finalist-rank {
            font-weight: 700;
            color: var(--primary-color);
            font-size: 1.1rem;
        }

        .finalist-team {
            font-weight: 600;
        }

        .finalist-prize {
            font-weight: 600;
            color: var(--accent-secondary);
        }

        .format-description {
            color: var(--text-secondary);
            margin-bottom: 2rem;
            font-style: italic;
        }
    </style>
</head>

<body>
    <div class="container">
        <a href="javascript:history.back()" class="back-button">
            <i class="fas fa-arrow-left"></i>
            Back to Admin Dashboard
        </a>

        <div class="header">
            <h1 class="tournament-title" id="tournament-title">Loading Tournament...</h1>
            <div class="tournament-info" id="tournament-info">
                <!-- Tournament info will be loaded here -->
            </div>
        </div>

        <div class="format-info" id="format-info" style="display: none;">
            <!-- Format information will be loaded here -->
        </div>

        <div class="tournament-stats" id="tournament-stats" style="display: none;">
            <!-- Tournament statistics will be loaded here -->
        </div>

        <div class="brackets-container" id="brackets-container">
            <div class="loading">
                <i class="fas fa-spinner fa-spin"></i>
                <p>Loading tournament brackets...</p>
            </div>
        </div>

        <div class="download-section" id="download-section" style="display: none;">
            <h3><i class="fas fa-download"></i> Download Tournament Brackets</h3>
            <p>Generate a comprehensive PDF with all match details, schedules, and bracket information.</p>
            <button class="download-btn" id="download-pdf-btn" onclick="downloadBracketsPDF()">
                <i class="fas fa-file-pdf"></i>
                Download Brackets PDF
            </button>
        </div>
    </div>

    <script>
        const API_BASE_URL = 'https://t2-237c.onrender.com';
        let tournamentData = null;
        let matchesData = [];

        // Get tournament slug from URL
        const urlParams = new URLSearchParams(window.location.search);
        const tournamentSlug = urlParams.get('slug');
        console.log('Tournament Slug:', tournamentSlug);

        if (!tournamentSlug) {
            document.getElementById('brackets-container').innerHTML = `
                <div class="no-brackets">
                    <i class="fas fa-exclamation-triangle" style="font-size: 3rem; margin-bottom: 1rem; color: #ffc107;"></i>
                    <h3>No Tournament Specified</h3>
                    <p>Please select a tournament from the admin dashboard.</p>
                </div>
            `;
        } else {
            loadTournamentBrackets();
        }

        async function loadTournamentBrackets() {
            try {
                // Load tournament data
                const response = await fetch(`${API_BASE_URL}/api/tournaments/slug/${tournamentSlug}`);
                if (!response.ok) {
                    throw new Error('Tournament not found');
                }

                const apiResponse = await response.json();
                console.log('API Response:', apiResponse);
                tournamentData = apiResponse.data || apiResponse;
                console.log('Tournament Data:', tournamentData);

                // Update page title and info
                document.getElementById('tournament-title').textContent = tournamentData.title;
                document.title = `${tournamentData.title} - Brackets | GamingNexus`;

                // Display tournament info
                displayTournamentInfo();

                // Display brackets based on format
                displayBrackets();

            } catch (error) {
                console.error('Error loading tournament:', error);
                document.getElementById('brackets-container').innerHTML = `
                    <div class="no-brackets">
                        <i class="fas fa-exclamation-circle" style="font-size: 3rem; margin-bottom: 1rem; color: #dc3545;"></i>
                        <h3>Error Loading Tournament</h3>
                        <p>${error.message}</p>
                    </div>
                `;
            }
        }

        function getMaxTeamsForDisplay() {
            const format = (tournamentData.format || 'single_elimination').toLowerCase();
            let maxTeams = tournamentData.maxTeams;

            // For KP format, calculate maxTeams from kpSettings if not set
            if (format === 'kp' && tournamentData.kpSettings && !maxTeams) {
                const kpSettings = tournamentData.kpSettings;
                maxTeams = (kpSettings.groupSize || 25) * (kpSettings.numberOfGroups || 4);
            }

            return maxTeams || 'Unlimited';
        }

        function displayTournamentInfo() {
            const participants = tournamentData.participants || [];
            const status = tournamentData.status || 'unknown';

            // Create status badge
            const statusBadge = `<span class="status-badge status-${status.replace('_', '-')}">${status.replace('_', ' ')}</span>`;

            const infoHtml = `
                <div class="info-item">
                    <strong>Format:</strong> ${tournamentData.format || 'Single Elimination'}
                </div>
                <div class="info-item">
                    <strong>Status:</strong> ${statusBadge}
                </div>
                <div class="info-item">
                    <strong>Game:</strong> ${tournamentData.game || 'Not specified'}
                </div>
            `;
            document.getElementById('tournament-info').innerHTML = infoHtml;

            // Display tournament statistics
            displayTournamentStats();

            // Show format information
            const formatInfo = document.getElementById('format-info');
            const format = tournamentData.format || 'single_elimination';
            let formatDescription = '';

            // Get format description from format configuration
            const formatConfig = getTournamentFormatConfig(format, participants.length);
            formatDescription = formatConfig ? formatConfig.description : `Tournament Format: ${format}`;

            formatInfo.innerHTML = `
                <h3><i class="fas fa-info-circle"></i> Tournament Format</h3>
                <p>${formatDescription}</p>
            `;
            formatInfo.style.display = 'block';

            // Show download section if registration is closed
            const downloadSection = document.getElementById('download-section');
            const downloadBtn = document.getElementById('download-pdf-btn');

            if (status === 'registration_closed' || status === 'active' || status === 'completed') {
                // Check if user is admin to show/hide download functionality
                checkAdminAccess().then(isAdmin => {
                    if (isAdmin) {
                        downloadSection.style.display = 'block';
                        downloadBtn.disabled = false;
                        downloadBtn.innerHTML = '<i class="fas fa-file-pdf"></i> Download Brackets PDF (Admin)';
                        downloadBtn.classList.remove('admin-only');
                    } else {
                        downloadSection.style.display = 'block';
                        downloadBtn.disabled = true;
                        downloadBtn.innerHTML = '<i class="fas fa-lock"></i> Download Restricted (Admin Only)';
                        downloadBtn.classList.add('admin-only');
                    }
                });
            } else {
                downloadSection.style.display = 'block';
                downloadBtn.disabled = true;
                downloadBtn.innerHTML = '<i class="fas fa-lock"></i> Available after registration closes';
            }
        }

        function displayTournamentStats() {
            const participants = tournamentData.participants || [];
            const format = (tournamentData.format || 'single_elimination').toLowerCase();

            // Get format configuration to calculate accurate stats
            const formatConfig = getTournamentFormatConfig(format, participants.length);

            let totalMatches = 0;
            let rounds = 0;
            let maxTeams = tournamentData.maxTeams; // Start with the value from the data

            console.log('Initial Tournament Data:', tournamentData);
            console.log('Format:', format);
            console.log('Max Teams from Backend:', maxTeams);
            console.log('Participants:', participants.length);

            // For KP format, calculate maxTeams from kpSettings if not already set correctly
            if (format === 'kp' && tournamentData.kpSettings) {
                const kpSettings = tournamentData.kpSettings;
                console.log('KP Settings:', kpSettings);
                // This line was the source of the error. It should use tournamentData.
                maxTeams = (kpSettings.groupSize || 25) * (kpSettings.numberOfGroups || 4);
            }

            // Fallback to participants length or unlimited if maxTeams is still not set
            if (!maxTeams) {
                maxTeams = participants.length || 'Unlimited';
            }

            console.log('Final Max Teams:', maxTeams);

            if (formatConfig) {
                // Calculate total matches from format configuration
                formatConfig.stages.forEach(stage => {
                    stage.tables.forEach(table => {
                        totalMatches += table.totalMatches;
                    });
                });
                rounds = formatConfig.stages.length;
            } else {
                // Fallback to basic calculations
                switch (format) {
                    case 'single_elimination':
                        totalMatches = Math.max(0, participants.length - 1);
                        rounds = Math.ceil(Math.log2(participants.length));
                        break;
                    case 'double_elimination':
                        totalMatches = Math.max(0, (participants.length * 2) - 2);
                        rounds = Math.ceil(Math.log2(participants.length)) + 1;
                        break;
                    case 'round_robin':
                        totalMatches = (participants.length * (participants.length - 1)) / 2;
                        rounds = participants.length - 1;
                        break;
                    case 'swiss':
                        rounds = Math.ceil(Math.log2(participants.length));
                        totalMatches = (participants.length / 2) * rounds;
                        break;
                    case 'kp':
                        totalMatches = 5; // 4 qualifiers + 1 final
                        rounds = 2; // Qualifiers + Finals
                        break;
                }
            }

            const statsHtml = `
                <div class="stat-card">
                    <span class="stat-number">${participants.length}/${maxTeams}</span>
                    <div class="stat-label">Registered Teams</div>
                </div>
                <div class="stat-card">
                    <span class="stat-number">${totalMatches}</span>
                    <div class="stat-label">Total Matches</div>
                </div>
                <div class="stat-card">
                    <span class="stat-number">${rounds}</span>
                    <div class="stat-label">Tournament Stages</div>
                </div>
                <div class="stat-card">
                    <span class="stat-number">‚Çπ${tournamentData.entryFee || 0}</span>
                    <div class="stat-label">Entry Fee</div>
                </div>
            `;

            document.getElementById('tournament-stats').innerHTML = statsHtml;
            document.getElementById('tournament-stats').style.display = 'grid';
        }

        function displayBrackets() {
            const participants = tournamentData.participants || [];
            const container = document.getElementById('brackets-container');

            if (participants.length === 0) {
                container.innerHTML = `
                    <div class="no-brackets">
                        <i class="fas fa-users-slash" style="font-size: 3rem; margin-bottom: 1rem; color: #6c757d;"></i>
                        <h3>No Teams Registered</h3>
                        <p>Brackets will be generated once teams register for this tournament.</p>
                    </div>
                `;
                return;
            }

            const format = (tournamentData.format || 'single_elimination').toLowerCase();

            // Handle all tournament formats dynamically
            displayTournamentBrackets(participants, container, format);
        }

        function displayTournamentBrackets(participants, container, format) {
            const formatConfig = getTournamentFormatConfig(format, participants.length);

            if (!formatConfig) {
                displayParticipantsList(participants, container);
                return;
            }

            let html = `<h3>${formatConfig.title}</h3>`;
            html += `<p class="format-description">${formatConfig.description}</p>`;

            // Create match tables for each stage
            formatConfig.stages.forEach((stage, stageIndex) => {
                html += `<div class="stage-section">`;
                html += `<div class="stage-header">`;
                html += `<h4><i class="fas fa-trophy"></i> ${stage.name}</h4>`;
                html += `<p>${stage.description}</p>`;
                html += `</div>`;

                // Create tables for this stage
                stage.tables.forEach((table, tableIndex) => {
                    html += createMatchTable(table, participants, stageIndex, tableIndex);
                });

                html += `</div>`;
            });

            // Add finalists table if tournament has finalists data
            if (tournamentData.finalists && tournamentData.finalists.length > 0) {
                html += createFinalistsTable(tournamentData.finalists);
            }

            container.innerHTML = html;
        }

        function getTournamentFormatConfig(format, participantCount) {
            // Use backend tournament data to generate format configuration
            const formatSettings = tournamentData.kpSettings || {};
            const matchSchedule = formatSettings.matchSchedule || [];

            switch (format) {
                case 'kp':
                    return generateKPFormatConfig(formatSettings, matchSchedule, participantCount);
                case 'single_elimination':
                    return generateSingleEliminationConfig(participantCount);
                case 'double_elimination':
                    return generateDoubleEliminationConfig(participantCount);
                case 'round_robin':
                    return generateRoundRobinConfig(participantCount);
                default:
                    return generateGenericFormatConfig(format, participantCount);
            }
        }

        function generateKPFormatConfig(kpSettings, matchSchedule, participantCount) {
            const groupSize = kpSettings.groupSize || 25;
            const numberOfGroups = kpSettings.numberOfGroups || 4;
            const qualifiersPerGroup = kpSettings.qualifiersPerGroup || 4;

            const qualifierTables = [];

            // Generate qualifier tables based on match schedule from backend
            if (matchSchedule.length > 0) {
                matchSchedule.forEach((match, index) => {
                    if (match.match && match.match.includes('Qualifier')) {
                        qualifierTables.push({
                            name: match.match,
                            type: 'qualifier',
                            teamsPerMatch: groupSize,
                            totalMatches: 1,
                            date: match.date,
                            teams: match.teams || `${groupSize} teams competing`
                        });
                    }
                });
            } else {
                // Fallback if no match schedule
                for (let i = 1; i <= numberOfGroups; i++) {
                    qualifierTables.push({
                        name: `Qualifier Match ${i}`,
                        type: 'qualifier',
                        teamsPerMatch: groupSize,
                        totalMatches: 1,
                        teams: `${groupSize} teams competing`
                    });
                }
            }

            // Add final match
            const finalMatch = matchSchedule.find(match => match.match && match.match.includes('Final'));
            const finalTable = {
                name: finalMatch ? finalMatch.match : 'Final Match',
                type: 'final',
                teamsPerMatch: numberOfGroups * qualifiersPerGroup,
                totalMatches: 1,
                date: finalMatch ? finalMatch.date : 'TBD',
                teams: `Top ${numberOfGroups * qualifiersPerGroup} Qualifiers`
            };

            return {
                title: 'KP Format Tournament',
                description: `${numberOfGroups} qualifier matches with ${groupSize} teams each, top ${qualifiersPerGroup} from each qualify for finals.`,
                stages: [
                    {
                        name: 'Qualifier Matches',
                        description: `${numberOfGroups} matches to select top ${qualifiersPerGroup} teams each`,
                        tables: qualifierTables
                    },
                    {
                        name: 'Finals',
                        description: `Top ${numberOfGroups * qualifiersPerGroup} teams compete for championship`,
                        tables: [finalTable]
                    }
                ]
            };
        }

        function generateSingleEliminationConfig(participantCount) {
            return {
                title: 'Single Elimination Tournament',
                description: 'Teams are eliminated after one loss. Winner advances through each round.',
                stages: [
                    {
                        name: 'Elimination Rounds',
                        description: 'Single elimination bracket progression',
                        tables: [
                            {
                                name: 'Main Bracket',
                                type: 'elimination',
                                teamsPerMatch: 2,
                                totalMatches: Math.max(0, participantCount - 1)
                            }
                        ]
                    }
                ]
            };
        }

        function generateDoubleEliminationConfig(participantCount) {
            return {
                title: 'Double Elimination Tournament',
                description: 'Teams must lose twice to be eliminated. Winners and losers brackets.',
                stages: [
                    {
                        name: 'Winners Bracket',
                        description: 'Main elimination bracket for undefeated teams',
                        tables: [
                            { name: 'Winners Bracket', type: 'winners', teamsPerMatch: 2, totalMatches: Math.max(0, participantCount - 1) }
                        ]
                    },
                    {
                        name: 'Losers Bracket',
                        description: 'Second chance bracket for eliminated teams',
                        tables: [
                            { name: 'Losers Bracket', type: 'losers', teamsPerMatch: 2, totalMatches: Math.max(0, participantCount - 2) }
                        ]
                    }
                ]
            };
        }

        function generateRoundRobinConfig(participantCount) {
            return {
                title: 'Round Robin Tournament',
                description: 'Every team plays every other team once.',
                stages: [
                    {
                        name: 'Round Robin Matches',
                        description: 'All teams play against each other',
                        tables: [
                            { name: 'Round Robin', type: 'round_robin', teamsPerMatch: 2, totalMatches: (participantCount * (participantCount - 1)) / 2 }
                        ]
                    }
                ]
            };
        }

        function generateGenericFormatConfig(format, participantCount) {
            return {
                title: `${format.charAt(0).toUpperCase() + format.slice(1)} Tournament`,
                description: `Tournament using ${format} format.`,
                stages: [
                    {
                        name: 'Tournament Matches',
                        description: 'Tournament progression matches',
                        tables: [
                            { name: 'Main Tournament', type: 'generic', teamsPerMatch: participantCount, totalMatches: 1 }
                        ]
                    }
                ]
            };
        }

        function createMatchTable(tableConfig, participants, stageIndex, tableIndex) {
            const tableId = `stage-${stageIndex}-table-${tableIndex}`;

            let html = `<div class="match-table-container">`;
            html += `<div class="match-table-header">`;
            html += `<h5><i class="fas fa-list"></i> ${tableConfig.name}</h5>`;
            html += `<span class="match-count">${tableConfig.totalMatches} ${tableConfig.totalMatches === 1 ? 'Match' : 'Matches'}</span>`;
            html += `</div>`;

            html += `<table class="match-table" id="${tableId}">`;
            html += `<thead>`;
            html += `<tr>`;
            html += `<th>Match #</th>`;
            html += `<th>Teams</th>`;
            html += `<th>Schedule</th>`;
            html += `</tr>`;
            html += `</thead>`;
            html += `<tbody>`;

            // Generate matches based on table type
            const matches = generateMatches(tableConfig, participants, stageIndex, tableIndex);
            matches.forEach((match, matchIndex) => {
                html += `<tr>`;
                html += `<td class="match-number">M${match.id}</td>`;
                html += `<td class="match-teams">${match.teams}</td>`;
                html += `<td class="match-schedule">${match.schedule}</td>`;
                html += `</tr>`;
            });

            html += `</tbody>`;
            html += `</table>`;
            html += `</div>`;

            return html;
        }

        function generateMatches(tableConfig, participants, stageIndex, tableIndex) {
            const matches = [];
            const matchIdBase = (stageIndex * 100) + (tableIndex * 10);

            if (tableConfig.type === 'qualifier') {
                // Distribute registered teams among qualifier matches
                const kpSettings = tournamentData.kpSettings || {};
                const numberOfGroups = kpSettings.numberOfGroups || 4;

                // Assign teams to specific qualifier matches (one team per match slot)
                // For example: Team 1 -> Match 1, Team 2 -> Match 2, etc.
                const assignedTeam = participants[tableIndex] || null;

                let teamsDisplay = '';
                let status = '';

                if (assignedTeam) {
                    teamsDisplay = assignedTeam.teamName;
                    status = 'Team Assigned';
                } else {
                    teamsDisplay = 'No team assigned';
                    status = 'Awaiting Team Assignment';
                }

                matches.push({
                    id: matchIdBase + 1,
                    teams: teamsDisplay,
                    status: status,
                    schedule: getMatchSchedule(matchIdBase + 1, tableConfig.date),
                    result: 'Pending'
                });
            } else if (tableConfig.type === 'final') {
                // Show all registered teams for final (they would qualify from qualifiers)
                const qualifiedTeams = participants.length > 0 ? `${participants.length} registered teams` : 'Awaiting Qualifiers';

                matches.push({
                    id: matchIdBase + 1,
                    teams: qualifiedTeams,
                    status: participants.length > 0 ? 'Teams Ready' : 'Awaiting Qualifiers',
                    schedule: getMatchSchedule(matchIdBase + 1, tableConfig.date),
                    result: 'Pending'
                });
            } else {
                // Generate standard matches with actual team distribution
                const teamsPerMatch = Math.ceil(participants.length / tableConfig.totalMatches);

                for (let i = 0; i < tableConfig.totalMatches; i++) {
                    const startIndex = i * teamsPerMatch;
                    const endIndex = Math.min(startIndex + teamsPerMatch, participants.length);
                    const matchTeams = participants.slice(startIndex, endIndex);

                    let teamsDisplay = 'TBD vs TBD';
                    if (matchTeams.length > 0) {
                        if (matchTeams.length === 1) {
                            teamsDisplay = `${matchTeams[0].teamName} vs TBD`;
                        } else if (matchTeams.length === 2) {
                            teamsDisplay = `${matchTeams[0].teamName} vs ${matchTeams[1].teamName}`;
                        } else {
                            teamsDisplay = `${matchTeams.length} teams competing`;
                        }
                    }

                    matches.push({
                        id: matchIdBase + i + 1,
                        teams: teamsDisplay,
                        status: matchTeams.length > 0 ? 'Teams Assigned' : 'Awaiting Teams',
                        schedule: getMatchSchedule(matchIdBase + i + 1, null),
                        result: 'Pending'
                    });
                }
            }

            return matches;
        }

        function createFinalistsTable(finalists) {
            let html = `<div class="finalists-section">`;
            html += `<div class="stage-header">`;
            html += `<h4><i class="fas fa-crown"></i> Tournament Finalists</h4>`;
            html += `<p>Final rankings updated by tournament admin</p>`;
            html += `</div>`;

            html += `<div class="finalists-table-container">`;
            html += `<table class="finalists-table">`;
            html += `<thead>`;
            html += `<tr>`;
            html += `<th>Rank</th>`;
            html += `<th>Team Name</th>`;
            html += `<th>Prize</th>`;
            html += `</tr>`;
            html += `</thead>`;
            html += `<tbody>`;

            finalists.forEach((finalist, index) => {
                const rank = index + 1;
                const prize = rank === 1 ? 'üèÜ Champion' : rank === 2 ? 'ü•à Runner-up' : rank === 3 ? 'ü•â 3rd Place' : `${rank}th Place`;

                html += `<tr>`;
                html += `<td class="finalist-rank">${rank}</td>`;
                html += `<td class="finalist-team">${finalist.teamName || finalist.name || `Team ${rank}`}</td>`;
                html += `<td class="finalist-prize">${prize}</td>`;
                html += `</tr>`;
            });

            html += `</tbody>`;
            html += `</table>`;
            html += `</div>`;
            html += `</div>`;

            return html;
        }

        function displaySingleEliminationBrackets(participants, container) {
            const numTeams = participants.length;
            const numRounds = Math.ceil(Math.log2(numTeams));

            // Generate matches data for all rounds
            matchesData = generateSingleEliminationMatches(participants, numRounds);

            let html = `<h3>Single Elimination Tournament Structure</h3>`;

            // Visual bracket overview
            html += '<div class="rounds-container">';
            for (let round = 1; round <= numRounds; round++) {
                const matchesInRound = Math.pow(2, numRounds - round);
                html += `<div class="bracket-round">`;
                html += `<div class="round-title">`;

                if (round === numRounds) {
                    html += 'Final';
                } else if (round === numRounds - 1) {
                    html += 'Semi-Final';
                } else if (round === numRounds - 2) {
                    html += 'Quarter-Final';
                } else {
                    html += `Round ${round}`;
                }

                html += `</div>`;

                for (let match = 0; match < matchesInRound; match++) {
                    const matchData = matchesData.find(m => m.round === round && m.matchInRound === match + 1);
                    html += `<div class="bracket-match">`;

                    if (matchData) {
                        html += `<div class="match-teams">`;
                        html += `<div class="team">
                            <span class="team-name">${matchData.team1 || 'TBD'}</span>
                            ${matchData.team1 ? `<span class="seed-number">#${matchData.seed1}</span>` : ''}
                        </div>`;
                        html += `<div class="team">
                            <span class="team-name">${matchData.team2 || 'TBD'}</span>
                            ${matchData.team2 ? `<span class="seed-number">#${matchData.seed2}</span>` : ''}
                        </div>`;
                        html += `</div>`;
                        html += `<div class="match-status">${matchData.status}</div>`;
                    }

                    html += `</div>`;
                }

                html += `</div>`;
            }
            html += '</div>';

            // Detailed match tables for each round
            html += '<div class="matches-section">';
            html += '<h3>Detailed Match Schedule</h3>';

            for (let round = 1; round <= numRounds; round++) {
                const roundMatches = matchesData.filter(m => m.round === round);
                if (roundMatches.length === 0) continue;

                html += `<div class="round-section">`;
                html += `<div class="round-header">`;

                if (round === numRounds) {
                    html += `<i class="fas fa-trophy"></i> Final Match`;
                } else if (round === numRounds - 1) {
                    html += `<i class="fas fa-medal"></i> Semi-Final Matches`;
                } else if (round === numRounds - 2) {
                    html += `<i class="fas fa-star"></i> Quarter-Final Matches`;
                } else {
                    html += `<i class="fas fa-play"></i> Round ${round} Matches`;
                }

                html += `</div>`;

                html += `<table class="match-table">`;
                html += `<thead>
                    <tr>
                        <th>Match #</th>
                        <th>Team 1</th>
                        <th>vs</th>
                        <th>Team 2</th>
                        <th>Scheduled Time</th>
                    </tr>
                </thead>
                <tbody>`;

                roundMatches.forEach(match => {
                    html += `<tr>
                        <td><span class="match-number">M${match.matchId}</span></td>
                        <td>${match.team1 || 'TBD'} ${match.team1 ? `<span class="seed-number">#${match.seed1}</span>` : ''}</td>
                        <td><span class="vs-separator">VS</span></td>
                        <td>${match.team2 || 'TBD'} ${match.team2 ? `<span class="seed-number">#${match.seed2}</span>` : ''}</td>
                        <td>${match.scheduledTime || 'TBD'}</td>
                    </tr>`;
                });

                html += `</tbody></table>`;
                html += `</div>`;
            }

            html += '</div>';
            container.innerHTML = html;
        }

        function generateSingleEliminationMatches(participants, numRounds) {
            const matches = [];
            let matchId = 1;

            for (let round = 1; round <= numRounds; round++) {
                const matchesInRound = Math.pow(2, numRounds - round);

                for (let matchInRound = 1; matchInRound <= matchesInRound; matchInRound++) {
                    let team1 = null, team2 = null, seed1 = null, seed2 = null;
                    let status = 'Scheduled';
                    let winnerAdvancesTo = '';

                    if (round === 1) {
                        // First round - assign actual teams
                        const team1Index = (matchInRound - 1) * 2;
                        const team2Index = (matchInRound - 1) * 2 + 1;

                        if (participants[team1Index]) {
                            team1 = participants[team1Index].teamName;
                            seed1 = team1Index + 1;
                        }
                        if (participants[team2Index]) {
                            team2 = participants[team2Index].teamName;
                            seed2 = team2Index + 1;
                        }

                        if (!team1 && !team2) {
                            status = 'No Teams';
                        } else if (!team1 || !team2) {
                            status = 'Bye';
                        }
                    } else {
                        status = 'Awaiting Previous Round';
                    }

                    // Determine where winner advances
                    if (round === numRounds) {
                        winnerAdvancesTo = 'Tournament Champion';
                    } else if (round === numRounds - 1) {
                        winnerAdvancesTo = 'Final';
                    } else if (round === numRounds - 2) {
                        winnerAdvancesTo = 'Semi-Final';
                    } else {
                        winnerAdvancesTo = `Round ${round + 1}`;
                    }

                    matches.push({
                        matchId: matchId++,
                        round: round,
                        matchInRound: matchInRound,
                        team1: team1,
                        team2: team2,
                        seed1: seed1,
                        seed2: seed2,
                        status: status,
                        scheduledTime: getMatchSchedule(matchId, null),
                        winnerAdvancesTo: winnerAdvancesTo
                    });
                }
            }

            return matches;
        }

        function displayDoubleEliminationBrackets(participants, container) {
            container.innerHTML = `
                <div class="no-brackets">
                    <i class="fas fa-construction" style="font-size: 3rem; margin-bottom: 1rem; color: #ffc107;"></i>
                    <h3>Double Elimination Brackets</h3>
                    <p>Double elimination bracket view is under development.</p>
                    <div style="margin-top: 2rem;">
                        <h4>Registered Teams (${participants.length}):</h4>
                        <div class="participants-grid">
                            ${participants.map((p, i) => `
                                <div class="participant-card">
                                    <h4>${p.teamName}</h4>
                                    <p><strong>Captain:</strong> ${p.captainEmail}</p>
                                    <p><strong>Players:</strong> ${p.players ? p.players.length : 0}</p>
                                    <span class="seed-number">Seed #${i + 1}</span>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                </div>
            `;
        }

        function displayRoundRobinBrackets(participants, container) {
            container.innerHTML = `
                <div class="no-brackets">
                    <i class="fas fa-table" style="font-size: 3rem; margin-bottom: 1rem; color: #17a2b8;"></i>
                    <h3>Round Robin Format</h3>
                    <p>In round robin, every team plays every other team once.</p>
                    <p><strong>Total matches needed:</strong> ${(participants.length * (participants.length - 1)) / 2}</p>
                    <div style="margin-top: 2rem;">
                        <h4>Registered Teams (${participants.length}):</h4>
                        <div class="participants-grid">
                            ${participants.map((p, i) => `
                                <div class="participant-card">
                                    <h4>${p.teamName}</h4>
                                    <p><strong>Captain:</strong> ${p.captainEmail}</p>
                                    <p><strong>Players:</strong> ${p.players ? p.players.length : 0}</p>
                                    <span class="seed-number">Team #${i + 1}</span>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                </div>
            `;
        }

        function displaySwissBrackets(participants, container) {
            container.innerHTML = `
                <div class="no-brackets">
                    <i class="fas fa-chess" style="font-size: 3rem; margin-bottom: 1rem; color: #6f42c1;"></i>
                    <h3>Swiss System Format</h3>
                    <p>Teams are paired based on their current standings each round.</p>
                    <div style="margin-top: 2rem;">
                        <h4>Registered Teams (${participants.length}):</h4>
                        <div class="participants-grid">
                            ${participants.map((p, i) => `
                                <div class="participant-card">
                                    <h4>${p.teamName}</h4>
                                    <p><strong>Captain:</strong> ${p.captainEmail}</p>
                                    <p><strong>Players:</strong> ${p.players ? p.players.length : 0}</p>
                                    <span class="seed-number">Team #${i + 1}</span>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                </div>
            `;
        }

        function displayParticipantsList(participants, container) {
            container.innerHTML = `
                <div style="text-align: center; margin-bottom: 2rem;">
                    <h3>Tournament Participants</h3>
                    <p>Bracket structure will be determined based on tournament format.</p>
                </div>
                <div class="participants-grid">
                    ${participants.map((p, i) => `
                        <div class="participant-card">
                            <h4>${p.teamName}</h4>
                            <p><strong>Captain:</strong> ${p.captainEmail}</p>
                            <p><strong>Players:</strong> ${p.players ? p.players.length : 0}</p>
                            <p><strong>Registration:</strong> ${new Date(p.registrationDate).toLocaleDateString()}</p>
                            <p><strong>Payment:</strong> ${p.paymentStatus || 'Pending'}</p>
                            <span class="seed-number">Team #${i + 1}</span>
                        </div>
                    `).join('')}
                </div>
            `;
        }

        async function checkAdminAccess() {
            try {
                // Get auth token from cookies
                const authToken = getCookie('auth_token');
                if (!authToken) {
                    return false;
                }

                // Check user role with the backend
                const response = await fetch(`${API_BASE_URL}/api/auth/me`, {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${authToken}`,
                        'Content-Type': 'application/json'
                    }
                });

                if (!response.ok) {
                    return false;
                }

                const userData = await response.json();
                return userData.role === 'admin';
            } catch (error) {
                console.error('Error checking admin access:', error);
                return false;
            }
        }

        function getCookie(name) {
            const value = `; ${document.cookie}`;
            const parts = value.split(`; ${name}=`);
            if (parts.length === 2) return parts.pop().split(';').shift();
            return null;
        }

        function getMatchSchedule(matchId, fallbackDate) {
            // Check for schedule events
            if (tournamentData.scheduleEvents) {
                const matchEvent = tournamentData.scheduleEvents.find(event =>
                    event.title.toLowerCase().includes('match') &&
                    event.title.toLowerCase().includes(matchId.toString())
                );
                if (matchEvent) {
                    const date = new Date(`${matchEvent.date}T${matchEvent.time}`);
                    return date.toLocaleString();
                }
            }

            // Check KP format match schedule
            if (tournamentData.format === 'kp' && tournamentData.kpSettings && tournamentData.kpSettings.matchSchedule) {
                const kpMatch = tournamentData.kpSettings.matchSchedule.find(match =>
                    match.match.toLowerCase().includes(matchId.toString()) ||
                    match.match.toLowerCase().includes('match')
                );
                if (kpMatch) {
                    const date = new Date(kpMatch.date);
                    return date.toLocaleString();
                }
            }

            // Fallback to provided date or TBD
            if (fallbackDate && fallbackDate !== 'TBD') {
                const date = new Date(fallbackDate);
                return date.toLocaleString();
            }

            return 'TBD';
        }

        async function downloadBracketsPDF() {
            // Check if user is admin
            const isAdmin = await checkAdminAccess();
            if (!isAdmin) {
                alert('Access denied. Only administrators can download tournament brackets.');
                return;
            }

            if (!tournamentData || !matchesData.length) {
                alert('No tournament data available for download.');
                return;
            }

            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();

            // Page 1: Tournament Overview
            doc.setFontSize(20);
            doc.setTextColor(15, 133, 211);
            doc.text(tournamentData.title, 20, 30);

            doc.setFontSize(12);
            doc.setTextColor(0, 0, 0);
            doc.text(`Tournament Brackets & Match Schedule`, 20, 45);
            doc.text(`Generated on: ${new Date().toLocaleDateString()}`, 20, 55);

            // Tournament Information
            doc.setFontSize(14);
            doc.text('Tournament Information', 20, 75);
            doc.setFontSize(10);

            const participants = tournamentData.participants || [];
            const infoText = [
                `Format: ${tournamentData.format || 'Single Elimination'}`,
                `Game: ${tournamentData.game || 'Not specified'}`,
                `Teams Registered: ${participants.length}`,
                `Maximum Teams: ${tournamentData.maxTeams || 'Unlimited'}`,
                `Entry Fee: ‚Çπ${tournamentData.entryFee || 0}`,
                `Prize Pool: ‚Çπ${tournamentData.prizePool || 0}`,
                `Status: ${tournamentData.status || 'Unknown'}`,
                `Registration Start: ${tournamentData.registrationStart ? new Date(tournamentData.registrationStart).toLocaleDateString() : 'TBD'}`,
                `Registration End: ${tournamentData.registrationEnd ? new Date(tournamentData.registrationEnd).toLocaleDateString() : 'TBD'}`,
                `Tournament Start: ${tournamentData.tournamentStart ? new Date(tournamentData.tournamentStart).toLocaleDateString() : 'TBD'}`,
                `Tournament End: ${tournamentData.tournamentEnd ? new Date(tournamentData.tournamentEnd).toLocaleDateString() : 'TBD'}`
            ];

            let yPos = 85;
            infoText.forEach(text => {
                doc.text(text, 20, yPos);
                yPos += 8;
            });

            // Registered Teams
            if (participants.length > 0) {
                doc.setFontSize(14);
                doc.text('Registered Teams', 20, yPos + 10);
                yPos += 20;

                const teamData = participants.map((p, index) => [
                    `#${index + 1}`,
                    p.teamName,
                    p.captainEmail,
                    p.players ? p.players.length : 0,
                    p.paymentStatus || 'Pending'
                ]);

                doc.autoTable({
                    head: [['Seed', 'Team Name', 'Captain Email', 'Players', 'Payment Status']],
                    body: teamData,
                    startY: yPos,
                    styles: { fontSize: 8 },
                    headStyles: { fillColor: [15, 133, 211] }
                });
            }

            // Page 2+: Match Details by Round
            const numRounds = Math.ceil(Math.log2(participants.length));

            for (let round = 1; round <= numRounds; round++) {
                doc.addPage();

                // Round header
                doc.setFontSize(18);
                doc.setTextColor(15, 133, 211);
                let roundTitle = '';
                if (round === numRounds) {
                    roundTitle = 'Final Match';
                } else if (round === numRounds - 1) {
                    roundTitle = 'Semi-Final Matches';
                } else if (round === numRounds - 2) {
                    roundTitle = 'Quarter-Final Matches';
                } else {
                    roundTitle = `Round ${round} Matches`;
                }

                doc.text(roundTitle, 20, 30);

                // Round matches table
                const roundMatches = matchesData.filter(m => m.round === round);
                if (roundMatches.length > 0) {
                    const matchTableData = roundMatches.map(match => [
                        `M${match.matchId}`,
                        match.team1 || 'TBD',
                        match.team2 || 'TBD',
                        match.scheduledTime || 'TBD',
                        match.status,
                        match.winnerAdvancesTo || 'Tournament Winner'
                    ]);

                    doc.autoTable({
                        head: [['Match #', 'Team 1', 'Team 2', 'Scheduled Time', 'Status', 'Winner Advances To']],
                        body: matchTableData,
                        startY: 50,
                        styles: { fontSize: 10 },
                        headStyles: { fillColor: [15, 133, 211] },
                        columnStyles: {
                            0: { cellWidth: 20 },
                            1: { cellWidth: 35 },
                            2: { cellWidth: 35 },
                            3: { cellWidth: 30 },
                            4: { cellWidth: 25 },
                            5: { cellWidth: 35 }
                        }
                    });

                    // Add match details section
                    let detailsY = doc.lastAutoTable.finalY + 20;
                    doc.setFontSize(12);
                    doc.setTextColor(0, 0, 0);
                    doc.text('Match Details & Notes:', 20, detailsY);

                    detailsY += 15;
                    doc.setFontSize(10);
                    roundMatches.forEach(match => {
                        doc.text(`Match ${match.matchId}: ${match.team1 || 'TBD'} vs ${match.team2 || 'TBD'}`, 25, detailsY);
                        detailsY += 8;
                        doc.text(`  ‚Ä¢ Status: ${match.status}`, 30, detailsY);
                        detailsY += 8;
                        doc.text(`  ‚Ä¢ Winner advances to: ${match.winnerAdvancesTo}`, 30, detailsY);
                        detailsY += 8;
                        doc.text(`  ‚Ä¢ Scheduled: ${match.scheduledTime || 'Time TBD'}`, 30, detailsY);
                        detailsY += 15;

                        if (detailsY > 250) {
                            doc.addPage();
                            detailsY = 30;
                        }
                    });
                }
            }

            // Final page: Tournament Rules & Notes
            doc.addPage();
            doc.setFontSize(16);
            doc.setTextColor(15, 133, 211);
            doc.text('Tournament Rules & Information', 20, 30);

            doc.setFontSize(10);
            doc.setTextColor(0, 0, 0);
            const rulesText = [
                '‚Ä¢ All matches must be played according to the scheduled time',
                '‚Ä¢ Teams must report match results to tournament organizers',
                '‚Ä¢ No-shows will result in automatic forfeit',
                '‚Ä¢ Disputes must be reported within 30 minutes of match completion',
                '‚Ä¢ Tournament organizers reserve the right to modify schedule if needed',
                '‚Ä¢ All participants must follow the game\'s terms of service',
                '‚Ä¢ Prize distribution will occur after tournament completion',
                '',
                'Contact Information:',
                `‚Ä¢ Tournament: ${tournamentData.title}`,
                `‚Ä¢ Format: ${tournamentData.format || 'Single Elimination'}`,
                `‚Ä¢ Total Prize Pool: ‚Çπ${tournamentData.prizePool || 0}`,
                '',
                'For support or questions, contact the tournament organizers.',
                '',
                `Document generated on: ${new Date().toLocaleString()}`
            ];

            let rulesY = 50;
            rulesText.forEach(text => {
                doc.text(text, 20, rulesY);
                rulesY += 8;
            });

            // Save the PDF
            const fileName = `${tournamentData.slug || 'tournament'}-brackets-${new Date().toISOString().split('T')[0]}.pdf`;
            doc.save(fileName);
        }
    </script>
</body>

</html>