<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tournament Brackets | GamingNexus</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap"
        rel="stylesheet" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="navbar.css">
    <!-- jsPDF for PDF generation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.23/jspdf.plugin.autotable.min.js"></script>

    <style>
        :root {
            --primary-color: #0f85d3;
            --bg-dark: #0D0A1A;
            --accent-secondary: #5D3FD3;
            --panel: #161329;
            --text-primary: #F0F0F0;
            --text-secondary: rgba(240, 240, 240, 0.7);
            --border-color: rgba(10, 250, 217, 0.2);
            --ease: 0.3s ease;
            --radius: 12px;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: var(--bg-dark);
            color: var(--text-primary);
            margin: 0;
            padding: 0;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
        }

        .header {
            text-align: center;
            margin-bottom: 2rem;
        }

        .tournament-title {
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
            background: linear-gradient(135deg, var(--primary-color), var(--accent-secondary));
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .tournament-info {
            display: flex;
            justify-content: center;
            gap: 2rem;
            margin-bottom: 2rem;
            flex-wrap: wrap;
        }

        .info-item {
            background: var(--panel);
            padding: 1rem 1.5rem;
            border-radius: var(--radius);
            border: 1px solid var(--border-color);
        }

        .brackets-container {
            background: var(--panel);
            border-radius: var(--radius);
            border: 1px solid var(--border-color);
            padding: 2rem;
            overflow-x: auto;
        }

        .bracket-round {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            min-width: 250px;
            margin-right: 2rem;
        }

        .bracket-match {
            background: rgba(15, 133, 211, 0.1);
            border: 1px solid var(--primary-color);
            border-radius: var(--radius);
            padding: 1rem;
            position: relative;
        }

        .match-teams {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .team {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
            transition: var(--ease);
        }

        .team.winner {
            background: rgba(40, 167, 69, 0.2);
            border: 1px solid #28a745;
        }

        .team.loser {
            opacity: 0.6;
        }

        .team-name {
            font-weight: 600;
        }

        .team-score {
            font-weight: 700;
            color: var(--primary-color);
        }

        .match-status {
            text-align: center;
            margin-top: 0.5rem;
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        .rounds-container {
            display: flex;
            align-items: flex-start;
            gap: 2rem;
            padding: 1rem 0;
        }

        .round-title {
            text-align: center;
            font-weight: 600;
            margin-bottom: 1rem;
            color: var(--primary-color);
        }

        .no-brackets {
            text-align: center;
            padding: 3rem;
            color: var(--text-secondary);
        }

        .loading {
            text-align: center;
            padding: 3rem;
        }

        .back-button {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            background: var(--primary-color);
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: var(--radius);
            text-decoration: none;
            font-weight: 600;
            transition: var(--ease);
            margin-bottom: 2rem;
        }

        .back-button:hover {
            background: var(--accent-secondary);
            transform: translateY(-2px);
        }

        .format-info {
            background: rgba(93, 63, 211, 0.1);
            border: 1px solid var(--accent-secondary);
            border-radius: var(--radius);
            padding: 1rem;
            margin-bottom: 2rem;
        }

        .participants-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .participant-card {
            background: var(--panel);
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            padding: 1rem;
        }

        .participant-card h4 {
            margin: 0 0 0.5rem 0;
            color: var(--primary-color);
        }

        .seed-number {
            background: var(--accent-secondary);
            color: white;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.8rem;
            font-weight: 600;
        }

        .matches-section {
            margin-top: 3rem;
        }

        .match-table {
            width: 100%;
            background: var(--panel);
            border-radius: var(--radius);
            border: 1px solid var(--border-color);
            margin-bottom: 2rem;
            overflow: hidden;
        }

        .match-table th,
        .match-table td {
            padding: 1rem;
            text-align: left;
            border-bottom: 1px solid var(--border-color);
        }

        .match-table th {
            background: rgba(15, 133, 211, 0.1);
            font-weight: 600;
            color: var(--primary-color);
        }

        .match-table tr:last-child td {
            border-bottom: none;
        }

        .match-table tr:hover {
            background: rgba(255, 255, 255, 0.02);
        }

        .match-number {
            font-weight: 700;
            color: var(--accent-secondary);
        }

        .vs-separator {
            color: var(--text-secondary);
            font-weight: 600;
            margin: 0 0.5rem;
        }

        .download-section {
            background: var(--panel);
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            padding: 2rem;
            text-align: center;
            margin-top: 3rem;
        }

        .download-btn {
            background: linear-gradient(135deg, var(--primary-color), var(--accent-secondary));
            color: white;
            padding: 1rem 2rem;
            border: none;
            border-radius: var(--radius);
            font-weight: 600;
            font-size: 1.1rem;
            cursor: pointer;
            transition: var(--ease);
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
        }

        .download-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(15, 133, 211, 0.3);
        }

        .download-btn:disabled {
            background: #6c757d;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .download-btn.admin-only {
            background: linear-gradient(135deg, #6c757d, #495057);
            border: 1px solid #6c757d;
        }

        .download-btn.admin-only:hover {
            transform: none;
            box-shadow: none;
        }

        .status-badge {
            padding: 0.25rem 0.75rem;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 600;
            text-transform: uppercase;
        }

        .status-registration-open {
            background: rgba(40, 167, 69, 0.2);
            color: #28a745;
            border: 1px solid #28a745;
        }

        .status-registration-closed {
            background: rgba(255, 193, 7, 0.2);
            color: #ffc107;
            border: 1px solid #ffc107;
        }

        .status-active {
            background: rgba(15, 133, 211, 0.2);
            color: var(--primary-color);
            border: 1px solid var(--primary-color);
        }

        .status-completed {
            background: rgba(108, 117, 125, 0.2);
            color: #6c757d;
            border: 1px solid #6c757d;
        }

        .round-section {
            margin-bottom: 3rem;
        }

        .round-header {
            background: linear-gradient(135deg, var(--primary-color), var(--accent-secondary));
            color: white;
            padding: 1rem 1.5rem;
            border-radius: var(--radius) var(--radius) 0 0;
            font-weight: 700;
            font-size: 1.2rem;
        }

        .tournament-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .stat-card {
            background: var(--panel);
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            padding: 1.5rem;
            text-align: center;
        }

        .stat-number {
            font-size: 2rem;
            font-weight: 700;
            color: var(--primary-color);
            display: block;
        }

        .stat-label {
            color: var(--text-secondary);
            font-size: 0.9rem;
            margin-top: 0.5rem;
        }

        /* Tournament Brackets Styling */
        .stage-section {
            margin-bottom: 3rem;
        }

        .stage-header {
            background: linear-gradient(135deg, var(--primary-color), var(--accent-secondary));
            color: white;
            padding: 1.5rem;
            border-radius: var(--radius) var(--radius) 0 0;
            margin-bottom: 0;
        }

        .stage-header h4 {
            margin: 0 0 0.5rem 0;
            font-size: 1.3rem;
        }

        .stage-header p {
            margin: 0;
            opacity: 0.9;
        }

        .match-table-container {
            background: var(--panel);
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            margin-bottom: 2rem;
            overflow: hidden;
        }

        .match-table-header {
            background: rgba(15, 133, 211, 0.1);
            padding: 1rem 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border-color);
        }

        .match-table-header h5 {
            margin: 0;
            color: var(--primary-color);
            font-size: 1.1rem;
        }

        .match-count {
            background: var(--primary-color);
            color: white;
            padding: 0.25rem 0.75rem;
            border-radius: 15px;
            font-size: 0.85rem;
            font-weight: 600;
        }

        .match-table {
            width: 100%;
            border-collapse: collapse;
        }

        .match-table th,
        .match-table td {
            padding: 1rem;
            text-align: left;
            border-bottom: 1px solid var(--border-color);
        }

        .match-table th {
            background: rgba(0, 0, 0, 0.1);
            font-weight: 600;
            color: var(--text-primary);
        }

        .match-table tr:hover {
            background: rgba(15, 133, 211, 0.05);
        }

        .match-table tr:last-child td {
            border-bottom: none;
        }

        .match-number {
            font-weight: 700;
            color: var(--accent-secondary);
            text-align: center;
        }

        .match-teams {
            font-weight: 500;
        }

        .match-status {
            padding: 0.25rem 0.75rem;
            border-radius: 15px;
            font-size: 0.85rem;
            font-weight: 600;
            text-align: center;
            background: rgba(108, 117, 125, 0.2);
            color: #6c757d;
        }

        .match-schedule {
            color: var(--text-secondary);
        }

        .finalists-section {
            margin-top: 3rem;
        }

        .finalists-table-container {
            background: var(--panel);
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            overflow: hidden;
        }

        .finalists-table {
            width: 100%;
            border-collapse: collapse;
        }

        .finalists-table th,
        .finalists-table td {
            padding: 1rem;
            text-align: center;
            border-bottom: 1px solid var(--border-color);
        }

        .finalists-table th {
            background: linear-gradient(135deg, #FFD700, #FFA500);
            color: #000;
            font-weight: 700;
        }

        .finalist-rank {
            font-weight: 700;
            color: var(--primary-color);
            font-size: 1.1rem;
        }

        .finalist-team {
            font-weight: 600;
        }

        .finalist-prize {
            font-weight: 600;
            color: var(--accent-secondary);
        }

        .format-description {
            color: var(--text-secondary);
            margin-bottom: 2rem;
            font-style: italic;
        }
    </style>
</head>

<body>
    <div class="container">
        <a href="javascript:history.back()" class="back-button">
            <i class="fas fa-arrow-left"></i>
            Back to Admin Dashboard
        </a>

        <div class="header">
            <h1 class="tournament-title" id="tournament-title">Loading Tournament...</h1>
            <div class="tournament-info" id="tournament-info">
                <!-- Tournament info will be loaded here -->
            </div>
        </div>

        <div class="format-info" id="format-info" style="display: none;">
            <!-- Format information will be loaded here -->
        </div>

        <div class="tournament-stats" id="tournament-stats" style="display: none;">
            <!-- Tournament statistics will be loaded here -->
        </div>

        <div class="brackets-container" id="brackets-container">
            <div class="loading">
                <i class="fas fa-spinner fa-spin"></i>
                <p>Loading tournament brackets...</p>
            </div>
        </div>

        <div class="download-section" id="download-section" style="display: none;">
            <h3><i class="fas fa-download"></i> Download Tournament Brackets</h3>
            <p>Generate a comprehensive PDF with all match details, schedules, and bracket information.</p>
            <button class="download-btn" id="download-pdf-btn" onclick="downloadBracketsPDF()">
                <i class="fas fa-file-pdf"></i>
                Download Brackets PDF
            </button>
        </div>
    </div>

    <script>
        const API_BASE_URL = 'https://t2-237c.onrender.com';
        let tournamentData = null;
        let matchesData = [];

        // Get tournament slug from URL
        const urlParams = new URLSearchParams(window.location.search);
        const tournamentSlug = urlParams.get('slug');
        console.log('Tournament Slug:', tournamentSlug);

        if (!tournamentSlug) {
            document.getElementById('brackets-container').innerHTML = `
                <div class="no-brackets">
                    <i class="fas fa-exclamation-triangle" style="font-size: 3rem; margin-bottom: 1rem; color: #ffc107;"></i>
                    <h3>No Tournament Specified</h3>
                    <p>Please select a tournament from the admin dashboard.</p>
                </div>
            `;
        } else {
            loadTournamentBrackets();
        }

        async function loadTournamentBrackets() {
            try {
                // Load tournament data
                const response = await fetch(`${API_BASE_URL}/api/tournaments/slug/${tournamentSlug}`);
                if (!response.ok) {
                    throw new Error('Tournament not found');
                }

                const apiResponse = await response.json();
                console.log('API Response:', apiResponse);
                tournamentData = apiResponse.data || apiResponse;
                console.log('Tournament Data:', tournamentData);

                // Update page title and info
                document.getElementById('tournament-title').textContent = tournamentData.title;
                document.title = `${tournamentData.title} - Brackets | GamingNexus`;

                // Display tournament info
                displayTournamentInfo();

                // Display brackets based on format
                displayBrackets();

            } catch (error) {
                console.error('Error loading tournament:', error);
                document.getElementById('brackets-container').innerHTML = `
                    <div class="no-brackets">
                        <i class="fas fa-exclamation-circle" style="font-size: 3rem; margin-bottom: 1rem; color: #dc3545;"></i>
                        <h3>Error Loading Tournament</h3>
                        <p>${error.message}</p>
                    </div>
                `;
            }
        }

        function getMaxTeamsForDisplay() {
            const format = (tournamentData.format || 'single_elimination').toLowerCase();
            let maxTeams = tournamentData.maxTeams;

            // For KP format, calculate maxTeams from kpSettings if not set
            if (format === 'kp' && tournamentData.kpSettings && !maxTeams) {
                const kpSettings = tournamentData.kpSettings;
                maxTeams = (kpSettings.groupSize || 25) * (kpSettings.numberOfGroups || 4);
            }

            return maxTeams || 'Unlimited';
        }

        function displayTournamentInfo() {
            const participants = tournamentData.participants || [];
            const status = tournamentData.status || 'unknown';

            // Create status badge
            const statusBadge = `<span class="status-badge status-${status.replace('_', '-')}">${status.replace('_', ' ')}</span>`;

            const infoHtml = `
                <div class="info-item">
                    <strong>Format:</strong> ${tournamentData.format || 'Single Elimination'}
                </div>
                <div class="info-item">
                    <strong>Status:</strong> ${statusBadge}
                </div>
                <div class="info-item">
                    <strong>Game:</strong> ${tournamentData.game || 'Not specified'}
                </div>
            `;
            document.getElementById('tournament-info').innerHTML = infoHtml;

            // Display tournament statistics
            displayTournamentStats();

            // Show format information
            const formatInfo = document.getElementById('format-info');
            const format = tournamentData.format || 'single_elimination';
            let formatDescription = '';

            // Get format description from format configuration
            const formatConfig = getTournamentFormatConfig(format, participants.length);
            formatDescription = formatConfig ? formatConfig.description : `Tournament Format: ${format}`;

            formatInfo.innerHTML = `
                <h3><i class="fas fa-info-circle"></i> Tournament Format</h3>
                <p>${formatDescription}</p>
            `;
            formatInfo.style.display = 'block';

            // Show download section if registration is closed
            const downloadSection = document.getElementById('download-section');
            const downloadBtn = document.getElementById('download-pdf-btn');

            if (status === 'registration_closed' || status === 'active' || status === 'completed') {
                // Check if user is admin to show/hide download functionality
                checkAdminAccess().then(isAdmin => {
                    if (isAdmin) {
                        downloadSection.style.display = 'block';
                        downloadBtn.disabled = false;
                        downloadBtn.innerHTML = '<i class="fas fa-file-pdf"></i> Download Brackets PDF (Admin)';
                        downloadBtn.classList.remove('admin-only');
                    } else {
                        downloadSection.style.display = 'block';
                        downloadBtn.disabled = true;
                        downloadBtn.innerHTML = '<i class="fas fa-lock"></i> Download Restricted (Admin Only)';
                        downloadBtn.classList.add('admin-only');
                    }
                });
            } else {
                downloadSection.style.display = 'block';
                downloadBtn.disabled = true;
                downloadBtn.innerHTML = '<i class="fas fa-lock"></i> Available after registration closes';
            }
        }

        function displayTournamentStats() {
            const participants = tournamentData.participants || [];
            const format = (tournamentData.format || 'single_elimination').toLowerCase();

            // Get format configuration to calculate accurate stats
            const formatConfig = getTournamentFormatConfig(format, participants.length);

            let totalMatches = 0;
            let rounds = 0;
            let maxTeams = tournamentData.maxTeams; // Start with the value from the data

            console.log('Initial Tournament Data:', tournamentData);
            console.log('Format:', format);
            console.log('Max Teams from Backend:', maxTeams);
            console.log('Participants:', participants.length);

            // For KP format, calculate maxTeams from kpSettings if not already set correctly
            if (format === 'kp' && tournamentData.kpSettings) {
                const kpSettings = tournamentData.kpSettings;
                console.log('KP Settings:', kpSettings);
                // This line was the source of the error. It should use tournamentData.
                maxTeams = (kpSettings.groupSize || 25) * (kpSettings.numberOfGroups || 4);
            }

            // Fallback to participants length or unlimited if maxTeams is still not set
            if (!maxTeams) {
                maxTeams = participants.length || 'Unlimited';
            }

            console.log('Final Max Teams:', maxTeams);

            if (formatConfig) {
                // Calculate total matches from format configuration
                formatConfig.stages.forEach(stage => {
                    stage.tables.forEach(table => {
                        totalMatches += table.totalMatches;
                    });
                });
                rounds = formatConfig.stages.length;
            } else {
                // Fallback to basic calculations
                switch (format) {
                    case 'single_elimination':
                        totalMatches = Math.max(0, participants.length - 1);
                        rounds = Math.ceil(Math.log2(participants.length));
                        break;
                    case 'double_elimination':
                        totalMatches = Math.max(0, (participants.length * 2) - 2);
                        rounds = Math.ceil(Math.log2(participants.length)) + 1;
                        break;
                    case 'round_robin':
                        totalMatches = (participants.length * (participants.length - 1)) / 2;
                        rounds = participants.length - 1;
                        break;
                    case 'swiss':
                        rounds = Math.ceil(Math.log2(participants.length));
                        totalMatches = (participants.length / 2) * rounds;
                        break;
                    case 'kp':
                        totalMatches = 5; // 4 qualifiers + 1 final
                        rounds = 2; // Qualifiers + Finals
                        break;
                }
            }

            const statsHtml = `
                <div class="stat-card">
                    <span class="stat-number">${participants.length}/${maxTeams}</span>
                    <div class="stat-label">Registered Teams</div>
                </div>
                <div class="stat-card">
                    <span class="stat-number">${totalMatches}</span>
                    <div class="stat-label">Total Matches</div>
                </div>
                <div class="stat-card">
                    <span class="stat-number">${rounds}</span>
                    <div class="stat-label">Tournament Stages</div>
                </div>
                <div class="stat-card">
                    <span class="stat-number">₹${tournamentData.entryFee || 0}</span>
                    <div class="stat-label">Entry Fee</div>
                </div>
            `;

            document.getElementById('tournament-stats').innerHTML = statsHtml;
            document.getElementById('tournament-stats').style.display = 'grid';
        }

        function displayBrackets() {
            const participants = tournamentData.participants || [];
            const container = document.getElementById('brackets-container');

            if (participants.length === 0) {
                container.innerHTML = `
                    <div class="no-brackets">
                        <i class="fas fa-users-slash" style="font-size: 3rem; margin-bottom: 1rem; color: #6c757d;"></i>
                        <h3>No Teams Registered</h3>
                        <p>Brackets will be generated once teams register for this tournament.</p>
                    </div>
                `;
                return;
            }

            const format = (tournamentData.format || 'single_elimination').toLowerCase();

            // Handle all tournament formats dynamically
            displayTournamentBrackets(participants, container, format);
        }

        function displayTournamentBrackets(participants, container, format) {
            const formatConfig = getTournamentFormatConfig(format, participants.length);

            if (!formatConfig) {
                displayParticipantsList(participants, container);
                return;
            }

            let html = `<h3>${formatConfig.title}</h3>`;
            html += `<p class="format-description">${formatConfig.description}</p>`;

            // Create match tables for each stage
            formatConfig.stages.forEach((stage, stageIndex) => {
                html += `<div class="stage-section">`;
                html += `<div class="stage-header">`;
                html += `<h4><i class="fas fa-trophy"></i> ${stage.name}</h4>`;
                html += `<p>${stage.description}</p>`;
                html += `</div>`;

                // Create tables for this stage
                stage.tables.forEach((table, tableIndex) => {
                    html += createMatchTable(table, participants, stageIndex, tableIndex);
                });

                html += `</div>`;
            });

            // Add finalists table if tournament has finalists data
            if (tournamentData.finalists && tournamentData.finalists.length > 0) {
                html += createFinalistsTable(tournamentData.finalists);
            }

            container.innerHTML = html;
        }

        function getTournamentFormatConfig(format, participantCount) {
            // Use backend tournament data to generate format configuration
            const formatSettings = tournamentData.kpSettings || {};
            const matchSchedule = formatSettings.matchSchedule || [];

            switch (format) {
                case 'kp':
                    return generateKPFormatConfig(formatSettings, matchSchedule, participantCount);
                case 'single_elimination':
                    return generateSingleEliminationConfig(participantCount);
                case 'double_elimination':
                    return generateDoubleEliminationConfig(participantCount);
                case 'round_robin':
                    return generateRoundRobinConfig(participantCount);
                default:
                    return generateGenericFormatConfig(format, participantCount);
            }
        }

        function generateKPFormatConfig(kpSettings, matchSchedule, participantCount) {
            const groupSize = kpSettings.groupSize || 25;
            const numberOfGroups = kpSettings.numberOfGroups || 4;
            const qualifiersPerGroup = kpSettings.qualifiersPerGroup || 4;

            const qualifierTables = [];

            // Generate qualifier tables based on match schedule from backend
            if (matchSchedule.length > 0) {
                matchSchedule.forEach((match, index) => {
                    if (match.match && match.match.includes('Qualifier')) {
                        qualifierTables.push({
                            name: match.match,
                            type: 'qualifier',
                            teamsPerMatch: groupSize,
                            totalMatches: 1,
                            date: match.date,
                            teams: match.teams || `${groupSize} teams competing`
                        });
                    }
                });
            } else {
                // Fallback if no match schedule
                for (let i = 1; i <= numberOfGroups; i++) {
                    qualifierTables.push({
                        name: `Qualifier Match ${i}`,
                        type: 'qualifier',
                        teamsPerMatch: groupSize,
                        totalMatches: 1,
                        teams: `${groupSize} teams competing`
                    });
                }
            }

            // Add final match
            const finalMatch = matchSchedule.find(match => match.match && match.match.includes('Final'));
            const finalTable = {
                name: finalMatch ? finalMatch.match : 'Final Match',
                type: 'final',
                teamsPerMatch: numberOfGroups * qualifiersPerGroup,
                totalMatches: 1,
                date: finalMatch ? finalMatch.date : 'TBD',
                teams: `Top ${numberOfGroups * qualifiersPerGroup} Qualifiers`
            };

            return {
                title: 'KP Format Tournament',
                description: `${numberOfGroups} qualifier matches with ${groupSize} teams each, top ${qualifiersPerGroup} from each qualify for finals.`,
                stages: [
                    {
                        name: 'Qualifier Matches',
                        description: `${numberOfGroups} matches to select top ${qualifiersPerGroup} teams each`,
                        tables: qualifierTables
                    },
                    {
                        name: 'Finals',
                        description: `Top ${numberOfGroups * qualifiersPerGroup} teams compete for championship`,
                        tables: [finalTable]
                    }
                ]
            };
        }

        function generateSingleEliminationConfig(participantCount) {
            return {
                title: 'Single Elimination Tournament',
                description: 'Teams are eliminated after one loss. Winner advances through each round.',
                stages: [
                    {
                        name: 'Elimination Rounds',
                        description: 'Single elimination bracket progression',
                        tables: [
                            {
                                name: 'Main Bracket',
                                type: 'elimination',
                                teamsPerMatch: 2,
                                totalMatches: Math.max(0, participantCount - 1)
                            }
                        ]
                    }
                ]
            };
        }

        function generateDoubleEliminationConfig(participantCount) {
            return {
                title: 'Double Elimination Tournament',
                description: 'Teams must lose twice to be eliminated. Winners and losers brackets.',
                stages: [
                    {
                        name: 'Winners Bracket',
                        description: 'Main elimination bracket for undefeated teams',
                        tables: [
                            { name: 'Winners Bracket', type: 'winners', teamsPerMatch: 2, totalMatches: Math.max(0, participantCount - 1) }
                        ]
                    },
                    {
                        name: 'Losers Bracket',
                        description: 'Second chance bracket for eliminated teams',
                        tables: [
                            { name: 'Losers Bracket', type: 'losers', teamsPerMatch: 2, totalMatches: Math.max(0, participantCount - 2) }
                        ]
                    }
                ]
            };
        }

        function generateRoundRobinConfig(participantCount) {
            return {
                title: 'Round Robin Tournament',
                description: 'Every team plays every other team once.',
                stages: [
                    {
                        name: 'Round Robin Matches',
                        description: 'All teams play against each other',
                        tables: [
                            { name: 'Round Robin', type: 'round_robin', teamsPerMatch: 2, totalMatches: (participantCount * (participantCount - 1)) / 2 }
                        ]
                    }
                ]
            };
        }

        function generateGenericFormatConfig(format, participantCount) {
            return {
                title: `${format.charAt(0).toUpperCase() + format.slice(1)} Tournament`,
                description: `Tournament using ${format} format.`,
                stages: [
                    {
                        name: 'Tournament Matches',
                        description: 'Tournament progression matches',
                        tables: [
                            { name: 'Main Tournament', type: 'generic', teamsPerMatch: participantCount, totalMatches: 1 }
                        ]
                    }
                ]
            };
        }

        function createMatchTable(tableConfig, participants, stageIndex, tableIndex) {
            const tableId = `stage-${stageIndex}-table-${tableIndex}`;

            let html = `<div class="match-table-container">`;
            html += `<div class="match-table-header">`;
            html += `<h5><i class="fas fa-list"></i> ${tableConfig.name}</h5>`;
            html += `<span class="match-count">${tableConfig.totalMatches} ${tableConfig.totalMatches === 1 ? 'Match' : 'Matches'}</span>`;
            html += `</div>`;

            html += `<table class="match-table" id="${tableId}">`;
            html += `<thead>`;
            html += `<tr>`;
            html += `<th>Match #</th>`;
            html += `<th>Teams</th>`;
            html += `<th>Schedule</th>`;
            html += `</tr>`;
            html += `</thead>`;
            html += `<tbody>`;

            // Generate matches based on table type
            const matches = generateMatches(tableConfig, participants, stageIndex, tableIndex);
            matches.forEach((match, matchIndex) => {
                html += `<tr>`;
                html += `<td class="match-number">M${match.id}</td>`;
                html += `<td class="match-teams">${match.teams}</td>`;
                html += `<td class="match-schedule">${match.schedule}</td>`;
                html += `</tr>`;
            });

            html += `</tbody>`;
            html += `</table>`;
            html += `</div>`;

            return html;
        }

        function generateMatches(tableConfig, participants, stageIndex, tableIndex) {
            const matches = [];
            const matchIdBase = (stageIndex * 100) + (tableIndex * 10);

            if (tableConfig.type === 'qualifier') {
                // Distribute registered teams among qualifier matches
                const kpSettings = tournamentData.kpSettings || {};
                const numberOfGroups = kpSettings.numberOfGroups || 4;

                // Assign teams to specific qualifier matches (one team per match slot)
                // For example: Team 1 -> Match 1, Team 2 -> Match 2, etc.
                const assignedTeam = participants[tableIndex] || null;

                let teamsDisplay = '';
                let status = '';

                if (assignedTeam) {
                    teamsDisplay = assignedTeam.teamName;
                    status = 'Team Assigned';
                } else {
                    teamsDisplay = 'No team assigned';
                    status = 'Awaiting Team Assignment';
                }

                matches.push({
                    id: matchIdBase + 1,
                    teams: teamsDisplay,
                    status: status,
                    schedule: getMatchSchedule(matchIdBase + 1, tableConfig.date),
                    result: 'Pending'
                });
            } else if (tableConfig.type === 'final') {
                // Show all registered teams for final (they would qualify from qualifiers)
                const qualifiedTeams = participants.length > 0 ? `${participants.length} registered teams` : 'Awaiting Qualifiers';

                matches.push({
                    id: matchIdBase + 1,
                    teams: qualifiedTeams,
                    status: participants.length > 0 ? 'Teams Ready' : 'Awaiting Qualifiers',
                    schedule: getMatchSchedule(matchIdBase + 1, tableConfig.date),
                    result: 'Pending'
                });
            } else {
                // Generate standard matches with actual team distribution
                const teamsPerMatch = Math.ceil(participants.length / tableConfig.totalMatches);

                for (let i = 0; i < tableConfig.totalMatches; i++) {
                    const startIndex = i * teamsPerMatch;
                    const endIndex = Math.min(startIndex + teamsPerMatch, participants.length);
                    const matchTeams = participants.slice(startIndex, endIndex);

                    let teamsDisplay = 'TBD vs TBD';
                    if (matchTeams.length > 0) {
                        if (matchTeams.length === 1) {
                            teamsDisplay = `${matchTeams[0].teamName} vs TBD`;
                        } else if (matchTeams.length === 2) {
                            teamsDisplay = `${matchTeams[0].teamName} vs ${matchTeams[1].teamName}`;
                        } else {
                            teamsDisplay = `${matchTeams.length} teams competing`;
                        }
                    }

                    matches.push({
                        id: matchIdBase + i + 1,
                        teams: teamsDisplay,
                        status: matchTeams.length > 0 ? 'Teams Assigned' : 'Awaiting Teams',
                        schedule: getMatchSchedule(matchIdBase + i + 1, null),
                        result: 'Pending'
                    });
                }
            }

            return matches;
        }

        function createFinalistsTable(finalists) {
            let html = `<div class="finalists-section">`;
            html += `<div class="stage-header">`;
            html += `<h4><i class="fas fa-crown"></i> Tournament Finalists</h4>`;
            html += `<p>Final rankings updated by tournament admin</p>`;
            html += `</div>`;

            html += `<div class="finalists-table-container">`;
            html += `<table class="finalists-table">`;
            html += `<thead>`;
            html += `<tr>`;
            html += `<th>Rank</th>`;
            html += `<th>Team Name</th>`;
            html += `<th>Prize</th>`;
            html += `</tr>`;
            html += `</thead>`;
            html += `<tbody>`;

            finalists.forEach((finalist, index) => {
                const rank = index + 1;
                const prize = rank === 1 ? '🏆 Champion' : rank === 2 ? '🥈 Runner-up' : rank === 3 ? '🥉 3rd Place' : `${rank}th Place`;

                html += `<tr>`;
                html += `<td class="finalist-rank">${rank}</td>`;
                html += `<td class="finalist-team">${finalist.teamName || finalist.name || `Team ${rank}`}</td>`;
                html += `<td class="finalist-prize">${prize}</td>`;
                html += `</tr>`;
            });

            html += `</tbody>`;
            html += `</table>`;
            html += `</div>`;
            html += `</div>`;

            return html;
        }

        function displaySingleEliminationBrackets(participants, container) {
            const numTeams = participants.length;
            const numRounds = Math.ceil(Math.log2(numTeams));

            // Generate matches data for all rounds
            matchesData = generateSingleEliminationMatches(participants, numRounds);

            let html = `<h3>Single Elimination Tournament Structure</h3>`;

            // Visual bracket overview
            html += '<div class="rounds-container">';
            for (let round = 1; round <= numRounds; round++) {
                const matchesInRound = Math.pow(2, numRounds - round);
                html += `<div class="bracket-round">`;
                html += `<div class="round-title">`;

                if (round === numRounds) {
                    html += 'Final';
                } else if (round === numRounds - 1) {
                    html += 'Semi-Final';
                } else if (round === numRounds - 2) {
                    html += 'Quarter-Final';
                } else {
                    html += `Round ${round}`;
                }

                html += `</div>`;

                for (let match = 0; match < matchesInRound; match++) {
                    const matchData = matchesData.find(m => m.round === round && m.matchInRound === match + 1);
                    html += `<div class="bracket-match">`;

                    if (matchData) {
                        html += `<div class="match-teams">`;
                        html += `<div class="team">
                            <span class="team-name">${matchData.team1 || 'TBD'}</span>
                            ${matchData.team1 ? `<span class="seed-number">#${matchData.seed1}</span>` : ''}
                        </div>`;
                        html += `<div class="team">
                            <span class="team-name">${matchData.team2 || 'TBD'}</span>
                            ${matchData.team2 ? `<span class="seed-number">#${matchData.seed2}</span>` : ''}
                        </div>`;
                        html += `</div>`;
                        html += `<div class="match-status">${matchData.status}</div>`;
                    }

                    html += `</div>`;
                }

                html += `</div>`;
            }
            html += '</div>';

            // Detailed match tables for each round
            html += '<div class="matches-section">';
            html += '<h3>Detailed Match Schedule</h3>';

            for (let round = 1; round <= numRounds; round++) {
                const roundMatches = matchesData.filter(m => m.round === round);
                if (roundMatches.length === 0) continue;

                html += `<div class="round-section">`;
                html += `<div class="round-header">`;

                if (round === numRounds) {
                    html += `<i class="fas fa-trophy"></i> Final Match`;
                } else if (round === numRounds - 1) {
                    html += `<i class="fas fa-medal"></i> Semi-Final Matches`;
                } else if (round === numRounds - 2) {
                    html += `<i class="fas fa-star"></i> Quarter-Final Matches`;
                } else {
                    html += `<i class="fas fa-play"></i> Round ${round} Matches`;
                }

                html += `</div>`;

                html += `<table class="match-table">`;
                html += `<thead>
                    <tr>
                        <th>Match #</th>
                        <th>Team 1</th>
                        <th>vs</th>
                        <th>Team 2</th>
                        <th>Scheduled Time</th>
                    </tr>
                </thead>
                <tbody>`;

                roundMatches.forEach(match => {
                    html += `<tr>
                        <td><span class="match-number">M${match.matchId}</span></td>
                        <td>${match.team1 || 'TBD'} ${match.team1 ? `<span class="seed-number">#${match.seed1}</span>` : ''}</td>
                        <td><span class="vs-separator">VS</span></td>
                        <td>${match.team2 || 'TBD'} ${match.team2 ? `<span class="seed-number">#${match.seed2}</span>` : ''}</td>
                        <td>${match.scheduledTime || 'TBD'}</td>
                    </tr>`;
                });

                html += `</tbody></table>`;
                html += `</div>`;
            }

            html += '</div>';
            container.innerHTML = html;
        }

        function generateSingleEliminationMatches(participants, numRounds) {
            const matches = [];
            let matchId = 1;

            for (let round = 1; round <= numRounds; round++) {
                const matchesInRound = Math.pow(2, numRounds - round);

                for (let matchInRound = 1; matchInRound <= matchesInRound; matchInRound++) {
                    let team1 = null, team2 = null, seed1 = null, seed2 = null;
                    let status = 'Scheduled';
                    let winnerAdvancesTo = '';

                    if (round === 1) {
                        // First round - assign actual teams
                        const team1Index = (matchInRound - 1) * 2;
                        const team2Index = (matchInRound - 1) * 2 + 1;

                        if (participants[team1Index]) {
                            team1 = participants[team1Index].teamName;
                            seed1 = team1Index + 1;
                        }
                        if (participants[team2Index]) {
                            team2 = participants[team2Index].teamName;
                            seed2 = team2Index + 1;
                        }

                        if (!team1 && !team2) {
                            status = 'No Teams';
                        } else if (!team1 || !team2) {
                            status = 'Bye';
                        }
                    } else {
                        status = 'Awaiting Previous Round';
                    }

                    // Determine where winner advances
                    if (round === numRounds) {
                        winnerAdvancesTo = 'Tournament Champion';
                    } else if (round === numRounds - 1) {
                        winnerAdvancesTo = 'Final';
                    } else if (round === numRounds - 2) {
                        winnerAdvancesTo = 'Semi-Final';
                    } else {
                        winnerAdvancesTo = `Round ${round + 1}`;
                    }

                    matches.push({
                        matchId: matchId++,
                        round: round,
                        matchInRound: matchInRound,
                        team1: team1,
                        team2: team2,
                        seed1: seed1,
                        seed2: seed2,
                        status: status,
                        scheduledTime: getMatchSchedule(matchId, null),
                        winnerAdvancesTo: winnerAdvancesTo
                    });
                }
            }

            return matches;
        }

        function displayDoubleEliminationBrackets(participants, container) {
            container.innerHTML = `
                <div class="no-brackets">
                    <i class="fas fa-construction" style="font-size: 3rem; margin-bottom: 1rem; color: #ffc107;"></i>
                    <h3>Double Elimination Brackets</h3>
                    <p>Double elimination bracket view is under development.</p>
                    <div style="margin-top: 2rem;">
                        <h4>Registered Teams (${participants.length}):</h4>
                        <div class="participants-grid">
                            ${participants.map((p, i) => `
                                <div class="participant-card">
                                    <h4>${p.teamName}</h4>
                                    <p><strong>Captain:</strong> ${p.captainEmail}</p>
                                    <p><strong>Players:</strong> ${p.players ? p.players.length : 0}</p>
                                    <span class="seed-number">Seed #${i + 1}</span>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                </div>
            `;
        }

        function displayRoundRobinBrackets(participants, container) {
            container.innerHTML = `
                <div class="no-brackets">
                    <i class="fas fa-table" style="font-size: 3rem; margin-bottom: 1rem; color: #17a2b8;"></i>
                    <h3>Round Robin Format</h3>
                    <p>In round robin, every team plays every other team once.</p>
                    <p><strong>Total matches needed:</strong> ${(participants.length * (participants.length - 1)) / 2}</p>
                    <div style="margin-top: 2rem;">
                        <h4>Registered Teams (${participants.length}):</h4>
                        <div class="participants-grid">
                            ${participants.map((p, i) => `
                                <div class="participant-card">
                                    <h4>${p.teamName}</h4>
                                    <p><strong>Captain:</strong> ${p.captainEmail}</p>
                                    <p><strong>Players:</strong> ${p.players ? p.players.length : 0}</p>
                                    <span class="seed-number">Team #${i + 1}</span>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                </div>
            `;
        }

        function displaySwissBrackets(participants, container) {
            container.innerHTML = `
                <div class="no-brackets">
                    <i class="fas fa-chess" style="font-size: 3rem; margin-bottom: 1rem; color: #6f42c1;"></i>
                    <h3>Swiss System Format</h3>
                    <p>Teams are paired based on their current standings each round.</p>
                    <div style="margin-top: 2rem;">
                        <h4>Registered Teams (${participants.length}):</h4>
                        <div class="participants-grid">
                            ${participants.map((p, i) => `
                                <div class="participant-card">
                                    <h4>${p.teamName}</h4>
                                    <p><strong>Captain:</strong> ${p.captainEmail}</p>
                                    <p><strong>Players:</strong> ${p.players ? p.players.length : 0}</p>
                                    <span class="seed-number">Team #${i + 1}</span>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                </div>
            `;
        }

        function displayParticipantsList(participants, container) {
            container.innerHTML = `
                <div style="text-align: center; margin-bottom: 2rem;">
                    <h3>Tournament Participants</h3>
                    <p>Bracket structure will be determined based on tournament format.</p>
                </div>
                <div class="participants-grid">
                    ${participants.map((p, i) => `
                        <div class="participant-card">
                            <h4>${p.teamName}</h4>
                            <p><strong>Captain:</strong> ${p.captainEmail}</p>
                            <p><strong>Players:</strong> ${p.players ? p.players.length : 0}</p>
                            <p><strong>Registration:</strong> ${new Date(p.registrationDate).toLocaleDateString()}</p>
                            <p><strong>Payment:</strong> ${p.paymentStatus || 'Pending'}</p>
                            <span class="seed-number">Team #${i + 1}</span>
                        </div>
                    `).join('')}
                </div>
            `;
        }

        async function checkAdminAccess() {
            try {
                // Get auth token from cookies
                const authToken = getCookie('auth_token');
                if (!authToken) {
                    return false;
                }

                // Check user role with the backend
                const response = await fetch(`${API_BASE_URL}/api/auth/me`, {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${authToken}`,
                        'Content-Type': 'application/json'
                    }
                });

                if (!response.ok) {
                    return false;
                }

                const userData = await response.json();
                return userData.role === 'admin';
            } catch (error) {
                console.error('Error checking admin access:', error);
                return false;
            }
        }

        function getCookie(name) {
            const value = `; ${document.cookie}`;
            const parts = value.split(`; ${name}=`);
            if (parts.length === 2) return parts.pop().split(';').shift();
            return null;
        }

        function getMatchSchedule(matchId, fallbackDate) {
            // Check for schedule events
            if (tournamentData.scheduleEvents) {
                const matchEvent = tournamentData.scheduleEvents.find(event =>
                    event.title.toLowerCase().includes('match') &&
                    event.title.toLowerCase().includes(matchId.toString())
                );
                if (matchEvent) {
                    const date = new Date(`${matchEvent.date}T${matchEvent.time}`);
                    return date.toLocaleString();
                }
            }

            // Check KP format match schedule
            if (tournamentData.format === 'kp' && tournamentData.kpSettings && tournamentData.kpSettings.matchSchedule) {
                const kpMatch = tournamentData.kpSettings.matchSchedule.find(match =>
                    match.match.toLowerCase().includes(matchId.toString()) ||
                    match.match.toLowerCase().includes('match')
                );
                if (kpMatch) {
                    const date = new Date(kpMatch.date);
                    return date.toLocaleString();
                }
            }

            // Fallback to provided date or TBD
            if (fallbackDate && fallbackDate !== 'TBD') {
                const date = new Date(fallbackDate);
                return date.toLocaleString();
            }

            return 'TBD';
        }

        async function downloadBracketsPDF() {
            // Check if user is admin
            const isAdmin = await checkAdminAccess();
            if (!isAdmin) {
                alert('Access denied. Only administrators can download tournament brackets.');
                return;
            }

            if (!tournamentData || !matchesData.length) {
                alert('No tournament data available for download.');
                return;
            }

            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();

            // Page 1: Tournament Overview
            doc.setFontSize(20);
            doc.setTextColor(15, 133, 211);
            doc.text(tournamentData.title, 20, 30);

            doc.setFontSize(12);
            doc.setTextColor(0, 0, 0);
            doc.text(`Tournament Brackets & Match Schedule`, 20, 45);
            doc.text(`Generated on: ${new Date().toLocaleDateString()}`, 20, 55);

            // Tournament Information
            doc.setFontSize(14);
            doc.text('Tournament Information', 20, 75);
            doc.setFontSize(10);

            const participants = tournamentData.participants || [];
            const infoText = [
                `Format: ${tournamentData.format || 'Single Elimination'}`,
                `Game: ${tournamentData.game || 'Not specified'}`,
                `Teams Registered: ${participants.length}`,
                `Maximum Teams: ${tournamentData.maxTeams || 'Unlimited'}`,
                `Entry Fee: ₹${tournamentData.entryFee || 0}`,
                `Prize Pool: ₹${tournamentData.prizePool || 0}`,
                `Status: ${tournamentData.status || 'Unknown'}`,
                `Registration Start: ${tournamentData.registrationStart ? new Date(tournamentData.registrationStart).toLocaleDateString() : 'TBD'}`,
                `Registration End: ${tournamentData.registrationEnd ? new Date(tournamentData.registrationEnd).toLocaleDateString() : 'TBD'}`,
                `Tournament Start: ${tournamentData.tournamentStart ? new Date(tournamentData.tournamentStart).toLocaleDateString() : 'TBD'}`,
                `Tournament End: ${tournamentData.tournamentEnd ? new Date(tournamentData.tournamentEnd).toLocaleDateString() : 'TBD'}`
            ];

            let yPos = 85;
            infoText.forEach(text => {
                doc.text(text, 20, yPos);
                yPos += 8;
            });

            // Registered Teams
            if (participants.length > 0) {
                doc.setFontSize(14);
                doc.text('Registered Teams', 20, yPos + 10);
                yPos += 20;

                const teamData = participants.map((p, index) => [
                    `#${index + 1}`,
                    p.teamName,
                    p.captainEmail,
                    p.players ? p.players.length : 0,
                    p.paymentStatus || 'Pending'
                ]);

                doc.autoTable({
                    head: [['Seed', 'Team Name', 'Captain Email', 'Players', 'Payment Status']],
                    body: teamData,
                    startY: yPos,
                    styles: { fontSize: 8 },
                    headStyles: { fillColor: [15, 133, 211] }
                });
            }

            // Page 2+: Match Details by Round
            const numRounds = Math.ceil(Math.log2(participants.length));

            for (let round = 1; round <= numRounds; round++) {
                doc.addPage();

                // Round header
                doc.setFontSize(18);
                doc.setTextColor(15, 133, 211);
                let roundTitle = '';
                if (round === numRounds) {
                    roundTitle = 'Final Match';
                } else if (round === numRounds - 1) {
                    roundTitle = 'Semi-Final Matches';
                } else if (round === numRounds - 2) {
                    roundTitle = 'Quarter-Final Matches';
                } else {
                    roundTitle = `Round ${round} Matches`;
                }

                doc.text(roundTitle, 20, 30);

                // Round matches table
                const roundMatches = matchesData.filter(m => m.round === round);
                if (roundMatches.length > 0) {
                    const matchTableData = roundMatches.map(match => [
                        `M${match.matchId}`,
                        match.team1 || 'TBD',
                        match.team2 || 'TBD',
                        match.scheduledTime || 'TBD',
                        match.status,
                        match.winnerAdvancesTo || 'Tournament Winner'
                    ]);

                    doc.autoTable({
                        head: [['Match #', 'Team 1', 'Team 2', 'Scheduled Time', 'Status', 'Winner Advances To']],
                        body: matchTableData,
                        startY: 50,
                        styles: { fontSize: 10 },
                        headStyles: { fillColor: [15, 133, 211] },
                        columnStyles: {
                            0: { cellWidth: 20 },
                            1: { cellWidth: 35 },
                            2: { cellWidth: 35 },
                            3: { cellWidth: 30 },
                            4: { cellWidth: 25 },
                            5: { cellWidth: 35 }
                        }
                    });

                    // Add match details section
                    let detailsY = doc.lastAutoTable.finalY + 20;
                    doc.setFontSize(12);
                    doc.setTextColor(0, 0, 0);
                    doc.text('Match Details & Notes:', 20, detailsY);

                    detailsY += 15;
                    doc.setFontSize(10);
                    roundMatches.forEach(match => {
                        doc.text(`Match ${match.matchId}: ${match.team1 || 'TBD'} vs ${match.team2 || 'TBD'}`, 25, detailsY);
                        detailsY += 8;
                        doc.text(`  • Status: ${match.status}`, 30, detailsY);
                        detailsY += 8;
                        doc.text(`  • Winner advances to: ${match.winnerAdvancesTo}`, 30, detailsY);
                        detailsY += 8;
                        doc.text(`  • Scheduled: ${match.scheduledTime || 'Time TBD'}`, 30, detailsY);
                        detailsY += 15;

                        if (detailsY > 250) {
                            doc.addPage();
                            detailsY = 30;
                        }
                    });
                }
            }

            // Final page: Tournament Rules & Notes
            doc.addPage();
            doc.setFontSize(16);
            doc.setTextColor(15, 133, 211);
            doc.text('Tournament Rules & Information', 20, 30);

            doc.setFontSize(10);
            doc.setTextColor(0, 0, 0);
            const rulesText = [
                '• All matches must be played according to the scheduled time',
                '• Teams must report match results to tournament organizers',
                '• No-shows will result in automatic forfeit',
                '• Disputes must be reported within 30 minutes of match completion',
                '• Tournament organizers reserve the right to modify schedule if needed',
                '• All participants must follow the game\'s terms of service',
                '• Prize distribution will occur after tournament completion',
                '',
                'Contact Information:',
                `• Tournament: ${tournamentData.title}`,
                `• Format: ${tournamentData.format || 'Single Elimination'}`,
                `• Total Prize Pool: ₹${tournamentData.prizePool || 0}`,
                '',
                'For support or questions, contact the tournament organizers.',
                '',
                `Document generated on: ${new Date().toLocaleString()}`
            ];

            let rulesY = 50;
            rulesText.forEach(text => {
                doc.text(text, 20, rulesY);
                rulesY += 8;
            });

            // Save the PDF
            const fileName = `${tournamentData.slug || 'tournament'}-brackets-${new Date().toISOString().split('T')[0]}.pdf`;
            doc.save(fileName);
        }
    </script>
</body>

</html>